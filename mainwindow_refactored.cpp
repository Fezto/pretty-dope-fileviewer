/** * PDFViewer implementation * --------------------------------------------------------------- * Holds logic for: * - Dynamic construction of page widgets. * - Lazy rendering based on scroll position. * - Zoom with smart re-render. * - Current page synchronization. */ #include "pdfviewer.h" #include<QScrollBar> #include<QDebug> #include<QResizeEvent> #include<cmath> PDFViewer::PDFViewer(QWidget *parent) : QScrollArea(parent), m_contentWidget(nullptr), m_contentLayout(nullptr), m_document(nullptr), m_currentPage(0), m_zoomFactor(1.0){setupUI();} void PDFViewer::setupUI(){setBackgroundRole(QPalette::Dark); // Allow keyboard focus so keyPressEvent is delivered here. setFocusPolicy(Qt::StrongFocus); setWidgetResizable(false); setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded); setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded); connect(verticalScrollBar(), &QScrollBar::valueChanged, this, &PDFViewer::onScrollValueChanged); } bool PDFViewer::setDocument(PDFDocument *document) { if (!document || !document->isLoaded()) return false; clearDocument(); m_document = document; buildPageWidgets(); m_currentPage = 0; emit currentPageChanged(m_currentPage); return true; } void PDFViewer::keyPressEvent(QKeyEvent *event) { if (!m_document || !m_document->isLoaded()) { QScrollArea::keyPressEvent(event); return; } switch (event->key()) { case Qt::Key_Right: case Qt::Key_Down: case Qt::Key_PageDown: goToPage(qMin(m_currentPage + 1, m_pageWidgets.size() - 1)); event->accept(); break; case Qt::Key_Left: case Qt::Key_Up: case Qt::Key_PageUp: goToPage(qMax(m_currentPage - 1, 0)); event->accept(); break; case Qt::Key_Home: goToPage(0); event->accept(); break; case Qt::Key_End: goToPage(m_pageWidgets.size() - 1); event->accept(); break; default: QScrollArea::keyPressEvent(event); break; } } void PDFViewer::clearDocument() { if (m_contentWidget) { takeWidget(); delete m_contentWidget; m_contentWidget = nullptr; m_contentLayout = nullptr; } m_pageWidgets.clear(); m_document = nullptr; m_currentPage = 0; } void PDFViewer::buildPageWidgets() { if (!m_document) return; m_contentWidget = new QWidget(); m_contentLayout = new QVBoxLayout(m_contentWidget); m_contentLayout->setAlignment(Qt::AlignTop | Qt::AlignHCenter); m_contentLayout->setSpacing(20); m_contentLayout->setContentsMargins(50, 50, 50, 50); int pageCount = m_document->pageCount(); m_pageWidgets.resize(pageCount); for (int i = 0; i < pageCount; ++i) { PDFPage *pageWidget = new PDFPage(); auto page = m_document->getPage(i); pageWidget->setPage(std::move(page), i); m_contentLayout->addWidget(pageWidget); m_pageWidgets[i] = pageWidget; } m_contentLayout->addStretch(1); setWidget(m_contentWidget); m_contentWidget->adjustSize(); m_contentLayout->update(); m_contentLayout->activate(); update(); updateContentMinSize(); int initialPages = qMin(5, pageCount); int initialDPI = int(DEFAULT_DPI * m_zoomFactor); for (int i = 0; i < initialPages; ++i) m_pageWidgets[i]->render(initialDPI); renderVisiblePages(); } void PDFViewer::renderVisiblePages() { if (!m_document || m_pageWidgets.isEmpty()) return; int scrollValue = verticalScrollBar()->value(); int viewportHeight = viewport()->height(); int avgPageHeight = 600; int firstVisible = qMax(0, (scrollValue / avgPageHeight) - PRERENDER_PAGES); int lastVisible = qMin(m_pageWidgets.size() - 1, ((scrollValue + viewportHeight) / avgPageHeight) + PRERENDER_PAGES); int dpi = qMax(DEFAULT_DPI, int(DEFAULT_DPI * m_zoomFactor)); for (int i = firstVisible; i <= lastVisible; ++i) { if (i >= 0 && i < m_pageWidgets.size()) m_pageWidgets[i]->render(dpi); } updateContentMinSize(); if (scrollValue == 0) { for (int i = 0; i < qMin(3, m_pageWidgets.size()); ++i) m_pageWidgets[i]->render(dpi); } } void PDFViewer::updateContentMinSize() { if (!m_contentWidget) return; int maxWidth = 0; int totalHeight = 0; for (auto *p : m_pageWidgets) { if (!p) continue; maxWidth = qMax(maxWidth, p->width()); totalHeight += p->height(); } if (m_contentLayout) { int spacing = m_contentLayout->spacing(); totalHeight += spacing * qMax(0, m_pageWidgets.size() - 1); QMargins m = m_contentLayout->contentsMargins(); maxWidth += m.left() + m.right(); totalHeight += m.top() + m.bottom(); } if (maxWidth > 0 && totalHeight > 0) { m_contentWidget->setMinimumSize(maxWidth, totalHeight + 1); m_contentWidget->updateGeometry(); } } void PDFViewer::goToPage(int pageIndex) { if (!m_document || pageIndex < 0 || pageIndex >= m_pageWidgets.size()) return; m_currentPage = pageIndex; m_pageWidgets[pageIndex]->render(qMax(DEFAULT_DPI, int(DEFAULT_DPI * m_zoomFactor))); PDFPage *pageWidget = m_pageWidgets[pageIndex]; int y = pageWidget->y(); int centerPos = y - (viewport()->height() - pageWidget->height()) / 2; verticalScrollBar()->setValue(qMax(0, centerPos)); emit currentPageChanged(m_currentPage); } void PDFViewer::setZoom(double factor) { m_zoomMode = ZoomMode::Free; applyZoom(factor, true); } QString PDFViewer::extractAllText() const { if (!m_document) return QString(); QString allText; for (int i = 0; i < m_pageWidgets.size(); ++i) { QString pageText = m_pageWidgets[i]->extractText(); if (!pageText.isEmpty()) { allText += QString("=== Page %1 ===\n").arg(i + 1); allText += pageText + "\n\n"; } } return allText; } // ----------------------------- Zoom helpers --------------------------------- void PDFViewer::applyZoom(double factor, bool preserveAnchor) { if (!m_document) return; if (factor < MIN_ZOOM) factor = MIN_ZOOM; if (factor > MAX_ZOOM) factor = MAX_ZOOM; int anchorPage = m_currentPage; double relOffset = 0.0; if (preserveAnchor) preserveScrollAnchorPreZoom(anchorPage, relOffset); m_zoomFactor = factor; for (auto pageWidget : m_pageWidgets) { auto page = m_document->getPage(pageWidget->pageIndex()); pageWidget->setPage(std::move(page), pageWidget->pageIndex()); } renderVisiblePages(); if (preserveAnchor) restoreScrollAnchorPostZoom(anchorPage, relOffset); emit zoomChanged(m_zoomFactor); } double PDFViewer::computeFitWidthFactor() const { if (m_pageWidgets.isEmpty() || !m_pageWidgets.first()->isRendered()) return m_zoomFactor; int viewportW = viewport()->width(); int pageW = m_pageWidgets.first()->width(); if (pageW <= 0) return m_zoomFactor; int margins = 0; if (m_contentLayout) { QMargins m = m_contentLayout->contentsMargins(); margins = m.left() + m.right(); } double available = viewportW - margins; if (available <= 0) return m_zoomFactor; return available / double(pageW); } double PDFViewer::computeFitPageFactor() const { if (m_pageWidgets.isEmpty() || !m_pageWidgets.first()->isRendered()) return m_zoomFactor; int viewportW = viewport()->width(); int viewportH = viewport()->height(); int pageW = m_pageWidgets.first()->width(); int pageH = m_pageWidgets.first()->height(); if (pageW <= 0 || pageH <= 0) return m_zoomFactor; int marginsW = 0, marginsH = 0; if (m_contentLayout) { QMargins m = m_contentLayout->contentsMargins(); marginsW = m.left() + m.right(); marginsH = m.top() + m.bottom(); } double availW = viewportW - marginsW; double availH = viewportH - marginsH; if (availW <= 0 || availH <= 0) return m_zoomFactor; double factorW = availW / double(pageW); double factorH = availH / double(pageH); return std::min(factorW, factorH); } void PDFViewer::preserveScrollAnchorPreZoom(int &anchorPage, double &relOffset) const { anchorPage = m_currentPage; if (anchorPage < 0 || anchorPage >= m_pageWidgets.size()) return; auto *page = m_pageWidgets[anchorPage]; int scrollY = verticalScrollBar()->value(); int top = page->y(); int offsetInPage = scrollY - top; if (offsetInPage < 0) offsetInPage = 0; relOffset = page->height() > 0 ? double(offsetInPage) / double(page->height()) : 0.0; } void PDFViewer::restoreScrollAnchorPostZoom(int anchorPage, double relOffset) { if (anchorPage < 0 || anchorPage >= m_pageWidgets.size()) return; auto *page = m_pageWidgets[anchorPage]; int target = page->y() + int(relOffset * page->height()); verticalScrollBar()->setValue(target); } void PDFViewer::updateAutoFitZoom() { if (m_zoomMode == ZoomMode::FitWidth) { applyZoom(computeFitWidthFactor(), false); } else if (m_zoomMode == ZoomMode::FitPage) { applyZoom(computeFitPageFactor(), false); } } void PDFViewer::zoomFitWidth() { m_zoomMode = ZoomMode::FitWidth; if (!m_pageWidgets.isEmpty()) m_pageWidgets.first()->render(int(DEFAULT_DPI * m_zoomFactor)); updateAutoFitZoom(); } void PDFViewer::zoomFitPage() { m_zoomMode = ZoomMode::FitPage; if (!m_pageWidgets.isEmpty()) m_pageWidgets.first()->render(int(DEFAULT_DPI * m_zoomFactor)); updateAutoFitZoom(); } void PDFViewer::onScrollValueChanged() { renderVisiblePages(); updateCurrentPage(); } void PDFViewer::updateCurrentPage() { if (m_pageWidgets.isEmpty()) return; int scrollValue = verticalScrollBar()->value(); int viewportCenter = scrollValue + viewport()->height() / 2; int newCurrentPage = 0; for (int i = 0; i < m_pageWidgets.size(); ++i) { PDFPage *pageWidget = m_pageWidgets[i]; int pageTop = pageWidget->y(); int pageBottom = pageTop + pageWidget->height(); if (viewportCenter >= pageTop && viewportCenter <= pageBottom) { newCurrentPage = i; break; } } if (newCurrentPage != m_currentPage) { m_currentPage = newCurrentPage; emit currentPageChanged(m_currentPage); } } void PDFViewer::resizeEvent(QResizeEvent *event) { QScrollArea::resizeEvent(event); if (m_zoomMode != ZoomMode::Free) { updateAutoFitZoom(); } } m_contentWidget->adjustSize(); m_contentLayout->update(); m_contentLayout->activate(); update(); updateContentMinSize(); int initialPages = qMin(5, pageCount); int initialDPI = int(DEFAULT_DPI * m_zoomFactor); for (int i = 0; i < initialPages; ++i) m_pageWidgets[i]->render(initialDPI); renderVisiblePages();